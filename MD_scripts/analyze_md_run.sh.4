#!/bin/bash
#
# NAME
#	analyze_md_run -- analyze a completed MD run
#
# SYNOPSIS
#	analyze_md_run simulation
#
# DESCRIPTION	
#	simulation is the base name used to create all of a run output
#	files.
#
#	analyze_md_run will look for all the files generated by an MD
#	simulation and try to run a large battery of analysis tests on
#	them.
#
#	The tests include:
#		Generation of auxiliary indexes
#		Generation of auxiliary trajectories for solute alone
#		Fitting the system to itself
#		Graph of potential energy evolution
#		Graph of kinetic energy evolution
#		Graph of total energy evolution
#		Graph of pressure evolution
#		Graph of temperature evolution
#		Backbone RMSD with respect to original conformation
#		Ligand RMSD with respect to original conformation
#		Backbone RMSF during the trajectory
#		Side chain RMSF during the trajectory
#		Ligand RMSF during the trajectory
#		Backbone radius of gyration
#		Secondary structure changes
#		Clusterize trajectory and output central structures in each
#			cluster for the system and for the solute
#		TO BE ADDED: compute H-bonds between protein and ligands
#
# AUTHOR
#	JosÂ´e R. Valverde, CNB/CSIC. jrvalverde@cnb.csic.es, 2014
#
#	Licensed under (at your option) either GNU/GPL or EUPL
#
# LICENSE:
#
#	Copyright 2014 JOSE R VALVERDE, CNB/CSIC.
#	Copyright 2018 JOSE R VALVERDE, CNB/CSIC.
#
#	EUPL
#
#       Licensed under the EUPL, Version 1.1 or \u2013 as soon they
#       will be approved by the European Commission - subsequent
#       versions of the EUPL (the "Licence");
#       You may not use this work except in compliance with the
#       Licence.
#       You may obtain a copy of the Licence at:
#
#       http://ec.europa.eu/idabc/eupl
#
#       Unless required by applicable law or agreed to in
#       writing, software distributed under the Licence is
#       distributed on an "AS IS" basis,
#       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
#       express or implied.
#       See the Licence for the specific language governing
#       permissions and limitations under the Licence.
#
#	GNU/GPL
#
#       This program is free software: you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation, either version 3 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

bold=`tput bold`
plain=`tput sgr0`
black=`tput setaf 0`
red=`tput setaf 1`
green=`tput setaf 2`
yellow=`tput setaf 3`
blue=`tput setaf 4`
magenta=`tput setaf 5`
cyan=`tput setaf 6`
lightgray=`tput setaf 7`

alias bold=`tput bold`
alias plain=`tput sgr0`
alias black=`tput setaf 0`
alias red=`tput setaf 1`
alias green=`tput setaf 2`
alias yellow=`tput setaf 3`
alias blue=`tput setaf 4`
alias magenta=`tput setaf 5`
alias cyan=`tput setaf 6`
alias lightgray=`tput setaf 7`

function boldblue {
    echo -n "$bold$(tput setaf 4) "
    echo -n "$*"
    echo "$(tput setaf 0)$plain"
}

function boldred {
    echo -n "$bold$(tput setaf 1)"
    echo -n "$*"
    echo "$(tput setaf 0)$plain"
}


function analyze_md_run {
    # arguments: MD run base name
    # requirements:
    #	$md.tpr		-- topology file
    #   $md.gro         -- final coordinates	(optional)
    #	$md.trr		-- original trajectory file
    #	$md.xtc		-- low-res trajectory file	(optional)
    #   ${md}_noPBC.xtc	-- low-res trajectory corrected for PBC	(optional)
    #	$md.edr		-- energy evolution	
    #
    #	Complex_water.pdb if water was used in the simulation
    #
    local md=$1
    local ligands=${2:-LIGANDS.ok}
    
    echo ""
    boldblue "analyze_md_run: Analyzing MD run: $md"
    echo ""
    
    # Minimization runs do not generate trajectories
    if [ ! -e $md.trr ] ; then
    	boldred "analyze_md_run ERROR: No trajectory found for MD run \"$md\"."
        return
    fi
    if [ -e ${md}.analysed ] ; then
        boldblue "analyze_md_run: MD run \"${md}\" is already analyzed"
        boldblue "analyze_md_run: remove file $md.analysed to re-analyze"
        return
    fi
    
    # ensure we have definitions of solute, solvent and chains
    if [ ! -e $md.ndx ] ; then
        boldblue "Building index"
        make_ext_index $md
    fi
    
    boldblue "Creating XTC file"
    if [ ! -e ${md}.xtc ] ; then
        # create a smaller low-res trajectory file
        # and get last time in trajectory
        echo "System" | $trjconv -f $md.trr -o $md.xtc -s $md.tpr -n $md.ndx \
		2>&1 | tee toxtc
        cat toxtc \
               | grep "Reading frame" \
               | tail -n 1 | sed -e 's/.* time //g' >  lasttime
	rm toxtc
    fi
    if [ ! -e lasttime ] ; then
    boldblue "Finding last time in trajectory"
        # find out last time in the trajectory from stderr of gmx check
        #lastt=`$g_check -f $md.xtc |& grep "Last frame" \
        #       | sed -e 's/.* time//g'`
        lastt=`$g_check -f $md.xtc |& grep "Reading frame" \
               | tail -n 1 | sed -e 's/.* time//g'`
    
        if [ "$lastt" == "" ] ; then 
            boldred "NO LAST FRAME!" 
            return; 
        fi
        echo "LAST TIME = $lastt" 
        echo "$lastt" > lasttime
    else
        lastt=`cat lasttime`
    fi

    # get last configuration if not present
    boldblue " Getting last configuration"
    if [ ! -e $md.gro ] ; then
        echo "System" | $trjconv -f $md.trr -s $md.tpr -n $md.ndx \
        	-o $md.gro -dump $lastt
    fi
    
    # correct trajectory for PBC if needed
    boldblue "Correcting for PBC"
    if [ ! -e ${md}_noPBC.xtc ] ; then
        echo "System" | $trjconv -s $md.tpr -f $md.xtc \
        		-o ${md}_noPBC.xtc -pbc mol -ur compact
    fi
    
    # Remove solvent
    boldblue "Removing solvent"
    if grep -q "^(\[ Solute \]" $md.ndx ; then
        # Create trajectory without solvent
        #echo "Solute" | $trjconv -f $md.xtc -s $md.tpr \
        #		-o ${md}_complex.xtc -n $md.ndx
        # prefer to work without PBC
        echo "Solute" | $trjconv -f ${md}_noPBC.xtc -s $md.tpr \
        		-o ${md}_complex.xtc -n $md.ndx
        echo "Solute" | $tpbconv -s $md.tpr -o ${md}_complex.tpr \
        		-n $md.ndx
        # dump initial (first, number 0) frame from the trajectory
        echo "Solute" | $trjconv -s ${md}_complex.tpr -f ${md}_complex.xtc \
        		-o ${md}_complex_0.gro -dump 0 -n $md.ndx
        # dump last frame from the trajectory
        echo "Solute" | $trjconv -s ${md}_complex.tpr -f ${md}_complex.xtc \
        		-o ${md}_complex_last.gro -dump $lastt -n $md.ndx
    elif grep -q "^(\[ SOL_ION \]" $md.ndx ; then
        echo "SOL_ION" | $trjconv -f ${md}_noPBC.xtc -s $md.tpr \
        		-o ${md}_complex.xtc -n $md.ndx
        echo "SOL_ION" | $tpbconv -s $md.tpr -o ${md}_complex.tpr \
        		-n $md.ndx
        # dump initial (first, number 0) frame from the trajectory
        echo "SOL_ION" | $trjconv -s ${md}_complex.tpr -f ${md}_complex.xtc \
        		-o ${md}_complex_0.gro -dump 0 -n $md.ndx
        # dump last frame from the trajectory
        echo "SOL_ION" | $trjconv -s ${md}_complex.tpr -f ${md}_complex.xtc \
        		-o ${md}_complex_last.gro -dump $lastt -n $md.ndx    
    else
        #ln -s $md.xtc ${md}_complex.xtc
        # prefer to work without PBC
        ln -s ${md}_noPBC.xtc ${md}_complex.xtc
        ln -s $md.tpr ${md}_complex.tpr
        ln -s $md.gro ${md}_complex_last.gro
    fi

    boldblue "Fitting system to itself"
    if [ ! -e ${md}_complex_fit.xtc ] ; then
        # fit system to itself for easier manipulation
        $trjconv -s ${md}_complex.tpr -f ${md}_complex.xtc -o ${md}_complex_fit.xtc -fit rot+tran <<END
System
System
END
    fi
    
    # Compute various graphs
    boldblue "Plotting system evolution"
    if [ ! -e ${md}_potenergy.xvg ] ; then
        echo "Potential"    | $g_energy -f $md.edr -o ${md}_potenergy.xvg
    fi
    if [ ! -e ${md}_kinenergy.xvg ] ; then
       echo "Kinetic-En"   | $g_energy -f $md.edr -o ${md}_kinenergy.xvg
    fi
    if [ ! -e ${md}_totenergy.xvg ] ; then
        echo "Total-Energy" | $g_energy -f $md.edr -o ${md}_totenergy.xvg
    fi
    if [ ! -e ${md}_pressure.xvg ] ; then
        echo "Pressure"     | $g_energy -f $md.edr -o ${md}_pressure.xvg
    fi
    if [ ! -e ${md}_potenergy.xvg ] ; then
        echo "Temperature"  | $g_energy -f $md.edr -o ${md}_temperature.xvg
        #echo "20" | g_energy -f $md.edr -o ${md}_volume.xvg
        #echo "21" | g_energy -f $md.edr -o ${md}_density.xvg
    fi
    # Make plots with running average
    for i in SVG PNG ; do
        $grace -hardcopy -hdevice $i -printfile ${md}_potenergy.$i   ${md}_potenergy.xvg   -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice $i -printfile ${md}_kinenergy.$i   ${md}_kinenergy.xvg   -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice $i -printfile ${md}_totenergy.$i   ${md}_totenergy.xvg   -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice $i -printfile ${md}_pressure.$i    ${md}_pressure.xvg    -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice $i -printfile ${md}_temperature.$i ${md}_temperature.xvg -pexec 'runavg(S0,100)'
    done

    #	1. RMSD (movement w.r.t. original conformation)
    #	Show structural stability using ns as time unit
    boldblue "Computing RMSD"
    if [ ! -e ${md}_complex_rmsd.xvg ] ; then
        $g_rms -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_complex_rmsd.xvg -tu ns <<END
Backbone
Backbone
END
        # and make a graph with running averages (100 data points)
        $grace -hardcopy -hdevice SVG -printfile ${md}_complex_rmsd.SVG ${md}_complex_rmsd.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_complex_rmsd.PNG ${md}_complex_rmsd.xvg -pexec 'runavg(S0,100)'
    fi

    #	2. RMSF (movility per atom/residue)
    #	    
    boldblue "Computing RMSF"
    #	backbone
    if [ ! -e ${md}_complex_rmsf_bb.xvg ] ; then
        echo "Backbone"  | $g_rmsf -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_complex_rmsf_bb.xvg -oq ${md}_complex_rmsf_bb.pdb -res

        $grace -hardcopy -hdevice SVG -printfile ${md}_complex_rmsf_bb.SVG ${md}_complex_rmsf_bb.xvg -pexec 'runavg(S0,100)' 
        $grace -hardcopy -hdevice PNG -printfile ${md}_complex_rmsf_bb.PNG ${md}_complex_rmsf_bb.xvg -pexec 'runavg(S0,100)' 
    fi    
    #	side chains
    if [ ! -e ${md}_complex_rmsf_sc.xvg ] ; then
        echo "SideChain" | $g_rmsf -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_complex_rmsf_sc.xvg -oq ${md}_complex_rmsf_sc.pdb

        $grace -hardcopy -hdevice SVG -printfile ${md}_complex_rmsf_sc.SVG ${md}_complex_rmsf_sc.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_complex_rmsf_sc.PNG ${md}_complex_rmsf_sc.xvg -pexec 'runavg(S0,100)'
    fi
    #	non-protein (ligands)
    if [ -s Ligands.pdb ] ; then
        echo "non-Protein" | $g_rmsf -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_complex_rmsf_np.xvg -oq ${md}_complex_rmsf_np.pdb
        $grace -hardcopy -hdevice SVG -printfile ${md}_complex_np_rmsf.SVG ${md}_complex_np_rmsf.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_complex_np_rmsf.PNG ${md}_complex_np_rmsf.xvg -pexec 'runavg(S0,100)'
    fi


    #	3. Radius of gyration (compactness and stability of the structure)
    #	backbone
    # The radius of gyration of a protein is a measure of its compactness. If a 
    # protein is stably folded, it will likely maintain a relatively steady value 
    # of R_g. If a protein unfolds, its R_g will change over time. 
    #
    boldblue "Computing radius of gyration"
    # ACF is the autocorrelation function.
    #
    if [ ! -e ${md}_complex_gyr.xvg ] ; then
        echo "Backbone" | $g_gyrate -s ${md}_complex.tpr \
                      -f ${md}_complex.xtc -o ${md}_complex_gyr.xvg \
		      -acf ${md}_acf.xvg
        $grace -hardcopy -hdevice SVG -printfile ${md}_complex_gyr.SVG ${md}_complex_gyr.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_complex_gyr.PNG ${md}_complex_gyr.xvg -pexec 'runavg(S0,100)'
    fi
    
    #	4. Compute secondary structure changes
    #
    boldblue "Computing secondary structure changes"
    if [ ! -e ${md}_complex_ss.xpm ] ; then
        echo "compute secondary structure"
        $do_dssp -f ${md}_complex.xtc -s ${md}_complex.tpr -sc ${md}_complex_scount.xvg -o ${md}_complex_ss.xpm -dt 10 <<END
MainChain
END

        $grace -nxy ${md}_complex_scount.xvg -hardcopy -hdevice SVG -printfile ${md}_complex_scount.SVG
        $grace -nxy ${md}_complex_scount.xvg -hardcopy -hdevice PNG -printfile ${md}_complex_scount.PNG

        cat > ps.m2p <<END
; Matrix options
titlefont       = Helvetica     ; Matrix title Postscript Font name
titlefontsize   = 20.0          ; Matrix title Font size (pt)
legend          = yes           ; Show the legend
legendfont      = Helvetica     ; Legend name Postscript Font name
legendfontsize  = 12.0          ; Legend name Font size (pt)
legendlabel                     ; Used when there is none in the .xpm
legend2label                    ; Id. when merging two xpm s
xbox            = 20.0           ; x-size of a matrix element
ybox            = 2.0          ; y-size of a matrix element
matrixspacing   = 20.0          ; Space between 2 matrices
xoffset         = 0.0           ; Between matrix and bounding box
yoffset         = 0.0           ; Between matrix and bounding box

; X-axis options
x-lineat0value  = no            ; Draw line at matrix value==0
x-major         = 100.0        ; Major tick spacing
x-minor         = 50.0         ; Id. Minor ticks
x-firstmajor    = 0.0           ; Offset for major tick
x-majorat0      = no            ; Additional Major tick at first frame
x-majorticklen  = 8.0           ; Length of major ticks
x-minorticklen  = 4.0           ; Id. Minor ticks
x-label         =               ; Used when there is none in the .xpm
x-font          = Helvetica     ; Axis label PostScript Font
x-fontsize      = 12            ; Axis label Font size (pt)
x-tickfont      = Helvetica     ; Tick label PostScript Font
x-tickfontsize  = 8             ; Tick label Font size (pt)

;Y-axis options
y-lineat0value  = none
y-major         = 10.0
y-minor         = 5.0
y-firstmajor    = 0.0
y-majorat0      = no
y-majorticklen  = 8.0
y-minorticklen  = 4.0
y-label         =
y-fontsize      = 12
y-font          = Helvetica
y-tickfontsize  = 8
y-tickfont      = Helvetica
END

        $xpm2ps -f ${md}_complex_ss.xpm -di ps.m2p -o ${md}_complex_ubq_ss.eps
    fi


    #	5. Clusterize trajectory and output central structures in
    #	each cluster.
    #g_cluster -s md_complex.tpr -f md_complex.trr -dist rmsd-distribution.xvg \
    #	-o clusters.xpm -sz cluster-sizes.xvg -tr cluster-transitions.xpm \
    #        -ntr cluster-transitions.xvg -clid cluster-id-over-time.xvg \
    #        -cl clusters.pdb -cutoff 0.25 -method gromos -dt 10 [ -av ]
    boldblue "Clustering"
    if [ ! -e ${md}_clusters.pdb ] ; then
        $g_cluster -s $md.tpr -f ${md}.xtc -cl ${md}_clusters.pdb -cutoff 0.5 \
	        -method gromos -dt 10 -dist ${md}_rmsd-dist.xvf  -o ${md}_rmsd-clust.xpm <<END
Protein
System
END
    fi
    # and now get the cluster average structures
    if [ ! -e ${md}_clustav.pdb ] ; then
        $g_cluster -s $md.tpr -f $md.xtc -cl ${md}_clustav.pdb -cutoff 0.5 \
	        -method gromos -dt 10 -av -dist ${md}_av_rmsd-dist.xvf  -o ${md}_av_rmsd-clust.xpm <<END
Protein
System
END
    fi
    #grep -q "^\[ SOL \]" $md.ndx
    #if [ $? -eq 0 ] ; then
    if egrep -q "^\[ SOL" $md.ndx ; then
	if [ ! -e ${md}_complex_clusters.pdb ] ; then
            # and now repeat for the complex alone
            #$g_cluster -s ${md}_complex.tpr -f ${md}_complex.trr -cl ${md}_complex_clusters.pdb -cutoff 0.5 \
	    $g_cluster -s ${md}_complex.tpr -f ${md}_complex.xtc -cl ${md}_complex_clusters.pdb -cutoff 0.5 \
	            -method gromos -dt 10 -dist ${md}_complex_rmsd-dist.xvf  -o ${md}_complex_rmsd-clust.xpm <<END
Protein
System
END
	fi
        # and now get the cluster average structures
	if [ ! -e ${md}_complex_clustav.pdb ] ; then
            $g_cluster -s ${md}_complex.tpr -f ${md}_complex.xtc -cl ${md}_complex_clustav.pdb -cutoff 0.5 \
	            -method gromos -dt 10 -av -dist ${md}_complex_av_rmsd-dist.xvf  -o ${md}_complex_av_rmsd-clust.xpm <<END
Protein
System
END
	fi
    fi

    # protein surface area
    boldblue "Computing SAS"
    if [ ! -e ${md}_protein_sasa.xvg ] ; then
        $g_sas -s ${md}.tpr -f ${md}.xtc -o ${md}_protein_sasa.xvg -tv ${md}_protein_vol.xvg <<END
Protein
Protein
END
        $grace -hardcopy -hdevice SVG -printfile ${md}_protein_sasa.SVG ${md}_protein_sasa.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_protein_sasa.PNG ${md}_protein_sasa.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice SVG -printfile ${md}_protein_vol.SVG ${md}_protein_vol.xvg -pexec 'runavg(S0,100)'
        $grace -hardcopy -hdevice PNG -printfile ${md}_protein_vol.PNG ${md}_protein_vol.xvg -pexec 'runavg(S0,100)'
    fi    
 
    # for all ligands
    # count H-bonds (protein vs. ligands)
    #	Luckily, when the Complex is generated a group named 'Other'
    #	is generated that includes all non-protein elements (without solvent)
    #
    # $ligands is a file listing in each line one ligand with its charge
    if [ -s $ligands ] ; then
        echo ""
        echo ">>> Analyzing ligands and ligand interactions"
        echo ""

	#
        # ligand (non-protein) RMSD and RMSF
    	#
	if [ ! -e ${md}_nonprot_rmsd.xvg ] ; then
            $g_rms -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_nonprot_rmsd.xvg -tu ns <<END
non-Protein
non-Protein
END
	    $grace -hardcopy -hdevice SVG -printfile ${md}_nonprot_rmsd.SVG ${md}_nonprot_rmsd.xvg -pexec 'runavg(S0,100)'
	    $grace -hardcopy -hdevice PNG -printfile ${md}_nonprot_rmsd.PNG ${md}_nonprot_rmsd.xvg -pexec 'runavg(S0,100)'
	fi
        if [ ! -e ${md}_nonprot_rmsf.xvg ] ; then
            echo "non-Protein"  | $g_rmsf -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_nonprot_rmsf.xvg -oq ${md}_nonprot_rmsf.pdb
            $grace -hardcopy -hdevice SVG -printfile ${md}_nonprot_rmsf.SVG ${md}_nonprot_rmsf.xvg -pexec 'runavg(S0,100)' 
            $grace -hardcopy -hdevice PNG -printfile ${md}_nonprot_rmsf.PNG ${md}_nonprot_rmsf.xvg -pexec 'runavg(S0,100)' 
	fi
        
        while read lig charge ; do
            # for each ligand
            if [ ! -e ${md}_${lig}_rmsd.xvg ] ; then
                $g_rms -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_${lig}_rmsd.xvg -tu ns <<END
$lig
$lig
END
	        $grace -hardcopy -hdevice SVG -printfile ${md}_${lig}_rmsd.SVG ${md}_${lig}_rmsd.xvg -pexec 'runavg(S0,100)'
	        $grace -hardcopy -hdevice PNG -printfile ${md}_${lig}_rmsd.PNG ${md}_${lig}_rmsd.xvg -pexec 'runavg(S0,100)'
	    fi
            if [ ! -e ${md}_${lig}_rmsf.xvg ] ; then
                echo "$lig"  | $g_rmsf -s ${md}_complex.tpr -f ${md}_complex_fit.xtc -o ${md}_${lig}_rmsf.xvg -oq ${md}_${lig}_rmsf.pdb
                $grace -hardcopy -hdevice SVG -printfile ${md}_${lig}_rmsf.SVG ${md}_${lig}_rmsf.xvg -pexec 'runavg(S0,100)' 
                $grace -hardcopy -hdevice PNG -printfile ${md}_${lig}_rmsf.PNG ${md}_${lig}_rmsf.xvg -pexec 'runavg(S0,100)' 
	    fi
        done <$ligands
        

	#
        # H-bonds between Protein and ligands
        #
        $g_hbond -f $md.xtc -s $md.tpr \
	        -num ${md}_hbnum.xvg -ac ${md}_hbac.xvg \
                <<END
Protein
Other
END
    	$grace -hardcopy -hdevice SVG -printfile ${md}_hbnum.SVG ${md}_hbnum.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice PNG -printfile ${md}_hbnum.PNG ${md}_hbnum.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice SVG -printfile ${md}_hbac.SVG ${md}_hbac.xvg -pexec 'runavg(S0,100)'
    	$grace -hardcopy -hdevice PNG -printfile ${md}_hbac.PNG ${md}_hbac.xvg -pexec 'runavg(S0,100)'

        # for each ligand
        #
        #	XXX JR XXX HACK HACK HACK HACK HACK HACK
        #
        #	WE HAVE A PROBLEM if Solvent has been used:
        #	gromacs duplicates the ligand groups, and so we cannot
        #	select them independently by name
        #
        #	On the other hand: the motivating behaviour is
        #	a known bug in Gromacs that has been assigned
        #	low priority because groups can still be selected
        #	by number.
        #
        #	use $md_complex.gro if it exists (implies solvent existed)
        #	  to make an index file without solvent interference
        #	else use $md.ndx instead (if there is no solvent there is no problem)
        #
        #	We could use the index of Complex_b4ion.pdb or Complex.pdb as a guide
        #	instead. This works because solvent is added AFTER the original 
        #	Complex and, so, the coordinate offsets in Complex.pdb are preserved.
        #	But that would imply using a hardcoded value and is a 'no-no'.
        #
        grep -q "^\[ SOL" $md.ndx
        if [ $? -eq 0 ] ; then
            echo "q" | $make_ndx -f ${md}_complex.pdb -o ${md}_complex.ndx
            ndx=${md}_complex.ndx
        else
            ndx=$md.ndx
        fi
        #
        while read lig charge ; do
            if [ ! -e ${md}_hb_${lig}_num.xvg ] ; then
                $g_hbond -f $md.xtc -s $md.tpr -n $ndx\
	                -num ${md}_hb_${lig}_num.xvg -ac ${md}_hb_${lig}_ac.xvg \
                        <<END
Protein
$lig
END
    	        $grace -hardcopy -hdevice SVG -printfile ${md}_hb_${lig}_num.SVG ${md}_hb_${lig}_num.xvg -pexec 'runavg(S0,100)'
    	        $grace -hardcopy -hdevice PNG -printfile ${md}_hb_${lig}_num.PNG ${md}_hb_${lig}_num.xvg -pexec 'runavg(S0,100)'
                $grace -hardcopy -hdevice SVG -printfile ${md}_hb_${lig}_ac.SVG ${md}_hb_${lig}_ac.xvg -pexec 'runavg(S0,100)'
                $grace -hardcopy -hdevice PNG -printfile ${md}_hb_${lig}_ac.PNG ${md}_hb_${lig}_ac.xvg -pexec 'runavg(S0,100)'
	    fi
        done < $ligands

	#
        # Solvent Accessible Surface Area and volume
        #
	
        # we need different commands for Protein and Protein+ligans
        if [ -s Ligands.pdb ] ; then
            # create an index of protein plus all ligands
            #	This works because group Other was created before addition
            #	of water and contains only the ligands with no solvent
            $make_ndx  -f ${md}.tpr -o pro+lig.ndx <<END
"Protein"|"Other"
q
END
            # use the extended group to compute an "extended" protein
            # surface area (protein + ligands)
            $g_sas -s ${md}.tpr -f ${md}.xtc -o ${md}_complex_sasa.xvg -tv ${md}_complex_vol.xvg \
    	        -n pro+lig.ndx <<END
Protein_Other
Protein_Other
END
    	    $grace -hardcopy -hdevice SVG -printfile ${md}_complex_sasa.SVG ${md}_complex_sasa.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice PNG -printfile ${md}_complex_sasa.PNG ${md}_complex_sasa.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice SVG -printfile ${md}_complex_vol.SVG ${md}_complex_vol.xvg -pexec 'runavg(S0,100)'
    	    $grace -hardcopy -hdevice PNG -printfile ${md}_complex_vol.PNG ${md}_complex_vol.xvg -pexec 'runavg(S0,100)'
	fi

    fi


    boldblue "Doing any remaining plot"
    # Last resort to ensure all XVG files are plotted
    for i in *.xvg ; do 
        n=`basename $x .xvg`
        if [ ! -e ${n}.SVG ] ; then
            $grace -hardcopy -hdevice SVG -printfile ${n}.SVG ${i}
        fi
        if [ ! -e ${n}.PNG ] ; then
            $grace -hardcopy -hdevice PNG -printfile ${n}.PNG ${i}
        fi
    done

    touch ${md}.analysed

    boldblue "DONE"
}

if [ "$LIBRARY"="no" ] ; then
    LIBRARY="yes"
    BASE=~/work/lenjuanes/script
    . $BASE/setup_cmds.sh
    . $BASE/make_ext_index.sh
    

    trajectory=$1
    ligands=$2

    # work on a subdirectory
    mkdir analysis
    cd analysis
    for i in ../$trajectory.* ; do
        if [ ! -e `basename $i` ] ; then
	    ln -s $i `basename $i`
 	fi
    done
     
    analyze_md_run $*

    cd ..
fi
